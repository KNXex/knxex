searchNodes=[{"doc":"Documentation for KNXexIP .","ref":"KNXexIP.html","title":"KNXexIP","type":"module"},{"doc":"KNX Common External Message Interface Control Field (cEMI). The cEMI control field has the following structure and bit order: + -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - + -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - + | Control Field 1 | Control Field 2 | + -- -- + -- -- + -- -- + -- -- + -- -- + -- -- + -- -- + -- -- + -- -- + -- -- + -- -- + -- -- + -- -- + -- -- + -- -- + -- -- + | 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | + -- -- + -- -- + -- -- + -- -- + -- -- + -- -- + -- -- + -- -- + -- -- + -- -- + -- -- + -- -- + -- -- + -- -- + -- -- + -- -- + The control field 1 has the following structure: Bit | -- -- -- + -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - 15 | Frame Type - 0 = for extended frame | 1 = for standard frame -- -- -- + -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - 14 | Reserved | -- -- -- + -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - 13 | Repeat Flag - 0 = repeat frame on medium in case of an error ( or on receive : repeated ) | 1 = do not repeat ( or on receive : not repeated ) -- -- -- + -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - 12 | System Broadcast - 0 = system broadcast | 1 = broadcast -- -- -- + -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - 11 | Priority - 0 = system ( reserved ) | 1 = normal ( also called alarm priority ) -- -- -- + 2 = urgent ( also called high priority ) 10 | 3 = low | -- -- -- + -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - 9 | Acknowledge Request - 0 = no ACK requested | ( L_Data . req ) 1 = ACK requested -- -- -- + -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - 8 | Confirm - 0 = no error | ( L_Data . con ) - 1 = error -- -- -- + -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - The control field 2 has the following structure: Bit | -- -- -- + -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - 7 | Destination Address Type - 0 = individual address | - 1 = group address -- -- -- + -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - 6 - 4 | Hop Count ( 0 - 7 ) -- -- -- + -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - 3 - 0 | Extended Frame Format - 0 = standard frame -- -- -- + -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -","ref":"KNXexIP.CEMIControlField.html","title":"KNXexIP.CEMIControlField","type":"module"},{"doc":"","ref":"KNXexIP.CEMIControlField.html#assert_name/2","title":"KNXexIP.CEMIControlField.assert_name/2","type":"function"},{"doc":"","ref":"KNXexIP.CEMIControlField.html#by_name/2","title":"KNXexIP.CEMIControlField.by_name/2","type":"function"},{"doc":"","ref":"KNXexIP.CEMIControlField.html#by_value/2","title":"KNXexIP.CEMIControlField.by_value/2","type":"function"},{"doc":"Explains the given control field. This returns an explain string. You may want to pipe the string into IO.puts/2 . Example output: Control Field 2 : Bit 0 - 3 : Extended Frame Format : 0 ( used for LTE ) Bit 4 - 6 : Hop Count : 5 Bit 7 : Destination Address Type : group Control Field 1 : Bit 8 : Confirm ( L_Data . con ) : no error Bit 9 : ACK Requested : no ACK requested Bit 10 + 11 : Priority : low Bit 12 : System Broadcast : no Bit 13 : Do - Not - Repeat / Original Flag : yes Bit 14 : -- reserved -- Bit 15 : Frame Type : standard","ref":"KNXexIP.CEMIControlField.html#explain/1","title":"KNXexIP.CEMIControlField.explain/1","type":"function"},{"doc":"Checks if the given cEMI Control Field has the ACK rqeuested bit set. Only relevant for L_Data.req frames.","ref":"KNXexIP.CEMIControlField.html#has_ack_requested_bit/1","title":"KNXexIP.CEMIControlField.has_ack_requested_bit/1","type":"macro"},{"doc":"Checks if the given cEMI Control Field has the do not repeat flag bit set (do not repeat on medium error).","ref":"KNXexIP.CEMIControlField.html#has_do_not_repeat/1","title":"KNXexIP.CEMIControlField.has_do_not_repeat/1","type":"macro"},{"doc":"Checks if the given cEMI Control Field has the error bit set (confirm = 1 =&gt; error). Only relevant for L_Data.con frames.","ref":"KNXexIP.CEMIControlField.html#has_error_bit/1","title":"KNXexIP.CEMIControlField.has_error_bit/1","type":"macro"},{"doc":"Checks if the given cEMI Control Field has the broadcast bit set.","ref":"KNXexIP.CEMIControlField.html#is_broadcast/1","title":"KNXexIP.CEMIControlField.is_broadcast/1","type":"macro"},{"doc":"Checks if the given cEMI Control Field has the destination address type bit set to group.","ref":"KNXexIP.CEMIControlField.html#is_destination_group/1","title":"KNXexIP.CEMIControlField.is_destination_group/1","type":"macro"},{"doc":"Checks if the given cEMI Control Field has the destination address type bit set to individual.","ref":"KNXexIP.CEMIControlField.html#is_destination_individual/1","title":"KNXexIP.CEMIControlField.is_destination_individual/1","type":"macro"},{"doc":"Checks if the given cEMI Control Field has the extended frame bit set.","ref":"KNXexIP.CEMIControlField.html#is_extended_frame/1","title":"KNXexIP.CEMIControlField.is_extended_frame/1","type":"macro"},{"doc":"","ref":"KNXexIP.CEMIControlField.html#macro_assert_name/2","title":"KNXexIP.CEMIControlField.macro_assert_name/2","type":"macro"},{"doc":"","ref":"KNXexIP.CEMIControlField.html#macro_by_name/2","title":"KNXexIP.CEMIControlField.macro_by_name/2","type":"macro"},{"doc":"","ref":"KNXexIP.CEMIControlField.html#macro_by_value/2","title":"KNXexIP.CEMIControlField.macro_by_value/2","type":"macro"},{"doc":"The KNX cEMI control field. It is a bitfield. See the module doc.","ref":"KNXexIP.CEMIControlField.html#t:t/0","title":"KNXexIP.CEMIControlField.t/0","type":"type"},{"doc":"KNX Constants.","ref":"KNXexIP.Constants.html","title":"KNXexIP.Constants","type":"module"},{"doc":"","ref":"KNXexIP.Constants.html#assert_name/2","title":"KNXexIP.Constants.assert_name/2","type":"function"},{"doc":"","ref":"KNXexIP.Constants.html#by_name/2","title":"KNXexIP.Constants.by_name/2","type":"function"},{"doc":"","ref":"KNXexIP.Constants.html#by_value/2","title":"KNXexIP.Constants.by_value/2","type":"function"},{"doc":"","ref":"KNXexIP.Constants.html#macro_assert_name/2","title":"KNXexIP.Constants.macro_assert_name/2","type":"macro"},{"doc":"","ref":"KNXexIP.Constants.html#macro_by_name/2","title":"KNXexIP.Constants.macro_by_name/2","type":"macro"},{"doc":"","ref":"KNXexIP.Constants.html#macro_by_value/2","title":"KNXexIP.Constants.macro_by_value/2","type":"macro"},{"doc":"KNX Data Information Block (DIB). Implements parsing/decoding of DIBs.","ref":"KNXexIP.DIB.html","title":"KNXexIP.DIB","type":"module"},{"doc":"Encodes a single DIB into a binary.","ref":"KNXexIP.DIB.html#encode/1","title":"KNXexIP.DIB.encode/1","type":"function"},{"doc":"Parses the DIBs from the given binary DIB data.","ref":"KNXexIP.DIB.html#parse/1","title":"KNXexIP.DIB.parse/1","type":"function"},{"doc":"Data Information Block. Always a two-item tuple, with the first item being the DIB identifier and the second item being the DIB data.","ref":"KNXexIP.DIB.html#t:dib/0","title":"KNXexIP.DIB.dib/0","type":"type"},{"doc":"Service Family name.","ref":"KNXexIP.DIB.html#t:service_family_name/0","title":"KNXexIP.DIB.service_family_name/0","type":"type"},{"doc":"KNXnet/IP Data Information Block &quot;Device Info&quot;.","ref":"KNXexIP.DIB.DeviceInfo.html","title":"KNXexIP.DIB.DeviceInfo","type":"module"},{"doc":"KNX medium type. Twisted Pair, IP, Radio Frequency, or Powerline.","ref":"KNXexIP.DIB.DeviceInfo.html#t:medium/0","title":"KNXexIP.DIB.DeviceInfo.medium/0","type":"type"},{"doc":"Represents a KNX Device Info. The Device Status bitfield only contains the programming mode on bit 0.","ref":"KNXexIP.DIB.DeviceInfo.html#t:t/0","title":"KNXexIP.DIB.DeviceInfo.t/0","type":"type"},{"doc":"KNXnet/IP Data Information Block &quot;IP Config&quot; (and &quot;Current IP Config&quot;).","ref":"KNXexIP.DIB.IPConfig.html","title":"KNXexIP.DIB.IPConfig","type":"module"},{"doc":"Converts a four item tuple IP address to a integer IP address (integer 32bit).","ref":"KNXexIP.DIB.IPConfig.html#inet_to_integer/1","title":"KNXexIP.DIB.IPConfig.inet_to_integer/1","type":"function"},{"doc":"Converts a integer IP address (integer 32bit) to a four item tuple.","ref":"KNXexIP.DIB.IPConfig.html#integer_to_inet/1","title":"KNXexIP.DIB.IPConfig.integer_to_inet/1","type":"function"},{"doc":"","ref":"KNXexIP.DIB.IPConfig.html#t:t/0","title":"KNXexIP.DIB.IPConfig.t/0","type":"type"},{"doc":"KNX data point types (DPT). This module only contains a subset of all DPTs. KNX datapoints all have a type as well as a value. The type must be known in order to encode and decode a datapoint. The datapoint type is a string, consisting of a main number and a subnumber seperated by a dot, e.g. &quot;1.001&quot; . The type carries information as to the format, encoding, range and unit of the datapoint. A full list of datapoint types can be seen in the KNX specification (document 3/7/2). Most datapoint types are mapped directly to a single-valued Elixir data type, but complex KNX values are mapped to tuples. The below table lists these mappings: Datapoint Type Elixir type Encoded Decoded 1.* boolean() &lt;&lt;1::6&gt;&gt; true 2.* {c, v}, all elements are integer() &lt;&lt;3::6&gt;&gt; {1, 1} 3.* {c, stepcode}, all elements are integer() &lt;&lt;3&gt;&gt; {0, 3} 4.* binary() &lt;&lt;&quot;T&quot;&gt;&gt; &quot;T&quot; 5.* integer() &lt;&lt;123&gt;&gt; 123 6.* (except 6.020) integer() &lt;&lt;123&gt;&gt; 123 6.020 {a, b, c, d, e, f}, all elements are integer() &lt;&lt;180&gt;&gt; {1, 0, 1, 1, 0, 4} 7.* integer() &lt;&lt;3421::16&gt;&gt; 3421 8.* integer() &lt;&lt;3421::16&gt;&gt; 3421 9.* float() &lt;&lt;13, 220&gt;&gt; 30.0 10.* {day, hour, minutes, seconds}, all elements are integer() &lt;204, 43, 12&gt;&gt; {6, 12, 43, 12} 11.* {day, month, year}, all elements are integer() &lt;&lt;12, 5, 19&gt;&gt; {12, 5, 2019} 12.* integer() &lt;&lt;203424034::32&gt;&gt; 203424034 13.* integer() &lt;&lt;203424034::32&gt;&gt; 203424034 14.* float() &lt;&lt;1174713696::32&gt;&gt; 8493.34375 15.* {d6, d5, d4, d3, d2, d1, e, p, d, c, index}, all elements are integer() &lt;&lt;32, 118, 57, 158&gt;&gt; {2, 0, 7, 6, 3, 9, 1, 0, 0, 1, 14} 16.* binary() &lt;&lt;79, 75, 0, 0, ...&gt;&gt; OK 17.* integer() &lt;&lt;61&gt;&gt; 61 18.* {c, scene_number}, all elements are integer() &lt;&lt;152&gt;&gt; {1, 24} 19.* {{fault, dst, clock_quality}, NaiveDateTime.t() | :invalid_date_and_time}, first tuple element = all elements boolean() &lt;&lt;122, 5, 7, ...&gt;&gt; {{false, true, false}, ~N[2022-05-07 17:46:35]} 20.* integer() &lt;&lt;13&gt;&gt; 13 21.* {b0, b1, b2, b3, b4, b5, b7}, all elements are boolean() &lt;&lt;13&gt;&gt; {true, false, true, true, false, false, false, false} 22.* {b0, b1, b2, b3, b4, b5, b7, ..., b15}, all elements are boolean() &lt;&lt;13, 15&gt;&gt; {true, true, true, true, false, ..., false} 23.* {a, b}, all elements are integer() &lt;&lt;3::6&gt;&gt; {1, 1} 24.* String.t() &lt;&lt;75, 78, ..., 0&gt;&gt; KNX is OK 25.* integer() &lt;&lt;58&gt;&gt; 58 26.* {active, scene_number}, all elements are integer() &lt;&lt;34&gt;&gt; {0, 34} 27.* List of {onoff_state, valid} Ã  16 elements, all tuple elements are integer() &lt;&lt;15, 240, 252, 15&gt;&gt; [{1, 0}, ..., {0, 1}, .. {1, 1}, ...] 28.* String.t() &lt;&lt;75, 78, ..., 0&gt;&gt; KNX is OK 29.* integer() &lt;&lt;255, 255, ...&gt;&gt; -92363274911746 219.* {lognumber, priority, app_area, error_class, attributes, alarmstatus_attributes}, all elements are integer() &lt;&lt;128, 2, 1, 3, 0, 3&gt;&gt; {128, 2, 1, 3, 0, 3}","ref":"KNXexIP.DPT.html","title":"KNXexIP.DPT","type":"module"},{"doc":"","ref":"KNXexIP.DPT.html#assert_name/2","title":"KNXexIP.DPT.assert_name/2","type":"function"},{"doc":"","ref":"KNXexIP.DPT.html#by_name/2","title":"KNXexIP.DPT.by_name/2","type":"function"},{"doc":"","ref":"KNXexIP.DPT.html#by_value/2","title":"KNXexIP.DPT.by_value/2","type":"function"},{"doc":"Decodes the value according to the DPT.","ref":"KNXexIP.DPT.html#decode/2","title":"KNXexIP.DPT.decode/2","type":"function"},{"doc":"Encodes the value according to the DPT.","ref":"KNXexIP.DPT.html#encode/2","title":"KNXexIP.DPT.encode/2","type":"function"},{"doc":"Get all defined DPTs. This will return a list of {type, name, value} , i.e. [{:dpt_1bit, &quot;DPT_Switch&quot;, &quot;1.001&quot;}] .","ref":"KNXexIP.DPT.html#get_dpts/0","title":"KNXexIP.DPT.get_dpts/0","type":"function"},{"doc":"","ref":"KNXexIP.DPT.html#macro_assert_name/2","title":"KNXexIP.DPT.macro_assert_name/2","type":"macro"},{"doc":"","ref":"KNXexIP.DPT.html#macro_by_name/2","title":"KNXexIP.DPT.macro_by_name/2","type":"macro"},{"doc":"","ref":"KNXexIP.DPT.html#macro_by_value/2","title":"KNXexIP.DPT.macro_by_value/2","type":"macro"},{"doc":"KNX ETS project.","ref":"KNXexIP.EtsProject.html","title":"KNXexIP.EtsProject","type":"module"},{"doc":"Returns a new empty ETS project struct.","ref":"KNXexIP.EtsProject.html#new/2","title":"KNXexIP.EtsProject.new/2","type":"function"},{"doc":"KNX completion status.","ref":"KNXexIP.EtsProject.html#t:completion_status/0","title":"KNXexIP.EtsProject.completion_status/0","type":"type"},{"doc":"KNX medium type. Twisted Pair, IP, Radio Frequency, or Powerline.","ref":"KNXexIP.EtsProject.html#t:medium/0","title":"KNXexIP.EtsProject.medium/0","type":"type"},{"doc":"Represents a KNX ETS project. Locations is currently not supported and ignored. group_addresses is keyed by the ID or the group address in x/y/z notation, depending on the parser setting :group_addresses_key .","ref":"KNXexIP.EtsProject.html#t:t/0","title":"KNXexIP.EtsProject.t/0","type":"type"},{"doc":"KNX group address information. Includes information about the group address from the ETS project.","ref":"KNXexIP.EtsProject.GroupAddressInfo.html","title":"KNXexIP.EtsProject.GroupAddressInfo","type":"module"},{"doc":"Represents a KNX group address.","ref":"KNXexIP.EtsProject.GroupAddressInfo.html#t:t/0","title":"KNXexIP.EtsProject.GroupAddressInfo.t/0","type":"type"},{"doc":"KNX manufacturer application program.","ref":"KNXexIP.EtsProject.Manufacturer.ApplicationProgram.html","title":"KNXexIP.EtsProject.Manufacturer.ApplicationProgram","type":"module"},{"doc":"Represents a KNX manufacturer application program.","ref":"KNXexIP.EtsProject.Manufacturer.ApplicationProgram.html#t:t/0","title":"KNXexIP.EtsProject.Manufacturer.ApplicationProgram.t/0","type":"type"},{"doc":"KNX manufacturer hardware.","ref":"KNXexIP.EtsProject.Manufacturer.Hardware.html","title":"KNXexIP.EtsProject.Manufacturer.Hardware","type":"module"},{"doc":"Represents KNX manufacturer hardware.","ref":"KNXexIP.EtsProject.Manufacturer.Hardware.html#t:t/0","title":"KNXexIP.EtsProject.Manufacturer.Hardware.t/0","type":"type"},{"doc":"KNX manufacturer Hardware-to-Program mapping.","ref":"KNXexIP.EtsProject.Manufacturer.Hardware.Hardware2Program.html","title":"KNXexIP.EtsProject.Manufacturer.Hardware.Hardware2Program","type":"module"},{"doc":"Represents a KNX manufacturer Hardware-to-Program mapping.","ref":"KNXexIP.EtsProject.Manufacturer.Hardware.Hardware2Program.html#t:t/0","title":"KNXexIP.EtsProject.Manufacturer.Hardware.Hardware2Program.t/0","type":"type"},{"doc":"KNX manufacturer hardware product.","ref":"KNXexIP.EtsProject.Manufacturer.Hardware.Product.html","title":"KNXexIP.EtsProject.Manufacturer.Hardware.Product","type":"module"},{"doc":"Represents a KNX manufacturer hardware product.","ref":"KNXexIP.EtsProject.Manufacturer.Hardware.Product.html#t:t/0","title":"KNXexIP.EtsProject.Manufacturer.Hardware.Product.t/0","type":"type"},{"doc":"KNX topology area.","ref":"KNXexIP.EtsProject.Topology.Area.html","title":"KNXexIP.EtsProject.Topology.Area","type":"module"},{"doc":"Represents a KNX topology area.","ref":"KNXexIP.EtsProject.Topology.Area.html#t:t/0","title":"KNXexIP.EtsProject.Topology.Area.t/0","type":"type"},{"doc":"KNX topology device.","ref":"KNXexIP.EtsProject.Topology.Device.html","title":"KNXexIP.EtsProject.Topology.Device","type":"module"},{"doc":"Represents a KNX topology device.","ref":"KNXexIP.EtsProject.Topology.Device.html#t:t/0","title":"KNXexIP.EtsProject.Topology.Device.t/0","type":"type"},{"doc":"KNX topology device communication object.","ref":"KNXexIP.EtsProject.Topology.Device.ComObject.html","title":"KNXexIP.EtsProject.Topology.Device.ComObject","type":"module"},{"doc":"Represents a KNX topology device communication object. The object size is in bits.","ref":"KNXexIP.EtsProject.Topology.Device.ComObject.html#t:t/0","title":"KNXexIP.EtsProject.Topology.Device.ComObject.t/0","type":"type"},{"doc":"KNX device status.","ref":"KNXexIP.EtsProject.Topology.Device.Status.html","title":"KNXexIP.EtsProject.Topology.Device.Status","type":"module"},{"doc":"Represents a KNX device status.","ref":"KNXexIP.EtsProject.Topology.Device.Status.html#t:t/0","title":"KNXexIP.EtsProject.Topology.Device.Status.t/0","type":"type"},{"doc":"KNX topology line.","ref":"KNXexIP.EtsProject.Topology.Line.html","title":"KNXexIP.EtsProject.Topology.Line","type":"module"},{"doc":"Represents a KNX topology line.","ref":"KNXexIP.EtsProject.Topology.Line.html#t:t/0","title":"KNXexIP.EtsProject.Topology.Line.t/0","type":"type"},{"doc":"KNX Frame. This contains a bunch of low level information from the frame.","ref":"KNXexIP.Frame.html","title":"KNXexIP.Frame","type":"module"},{"doc":"KNX request types.","ref":"KNXexIP.Frame.html#t:request_type/0","title":"KNXexIP.Frame.request_type/0","type":"type"},{"doc":"KNX frame. The :body key might be a struct or the binary data, if the frame was not parsed.","ref":"KNXexIP.Frame.html#t:t/0","title":"KNXexIP.Frame.t/0","type":"type"},{"doc":"This module contains all the binary matching logic for the KNX frames (inlined through macros from the actual frame modules). Frames that are inlined into this module (using use ), have to implement the decode_frame/3 function with binary matching in the header.","ref":"KNXexIP.FrameDecoder.html","title":"KNXexIP.FrameDecoder","type":"module"},{"doc":"Decodes a KNX frame from a binary string. :ignore will be returned as a default fallback, if no frame decoder matches.","ref":"KNXexIP.FrameDecoder.html#decode_frame/3","title":"KNXexIP.FrameDecoder.decode_frame/3","type":"function"},{"doc":"KNX Description Request Frame. This frame does have a frame encoder implementation.","ref":"KNXexIP.Frames.DescriptionRequestFrame.html","title":"KNXexIP.Frames.DescriptionRequestFrame","type":"module"},{"doc":"Represents a KNX Description Request frame.","ref":"KNXexIP.Frames.DescriptionRequestFrame.html#t:t/0","title":"KNXexIP.Frames.DescriptionRequestFrame.t/0","type":"type"},{"doc":"KNX Description Response Frame. This frame does have a frame encoder implementation.","ref":"KNXexIP.Frames.DescriptionResponseFrame.html","title":"KNXexIP.Frames.DescriptionResponseFrame","type":"module"},{"doc":"Represents a KNX Description Response frame.","ref":"KNXexIP.Frames.DescriptionResponseFrame.html#t:t/0","title":"KNXexIP.Frames.DescriptionResponseFrame.t/0","type":"type"},{"doc":"Frame Encoder protocol for the Multicast Server.","ref":"KNXexIP.Frames.FrameEncoder.html","title":"KNXexIP.Frames.FrameEncoder","type":"protocol"},{"doc":"Encodes the structure into a bitstring for the request payload.","ref":"KNXexIP.Frames.FrameEncoder.html#encode/2","title":"KNXexIP.Frames.FrameEncoder.encode/2","type":"function"},{"doc":"Returns the correct request type for the given datatype.","ref":"KNXexIP.Frames.FrameEncoder.html#get_request_type/1","title":"KNXexIP.Frames.FrameEncoder.get_request_type/1","type":"function"},{"doc":"","ref":"KNXexIP.Frames.FrameEncoder.html#t:t/0","title":"KNXexIP.Frames.FrameEncoder.t/0","type":"type"},{"doc":"KNX Routing Busy Frame.","ref":"KNXexIP.Frames.RoutingBusyFrame.html","title":"KNXexIP.Frames.RoutingBusyFrame","type":"module"},{"doc":"Represents a KNX Routing Busy frame.","ref":"KNXexIP.Frames.RoutingBusyFrame.html#t:t/0","title":"KNXexIP.Frames.RoutingBusyFrame.t/0","type":"type"},{"doc":"KNX Routing Indication Frame. This frame does have a frame encoder implementation. The payload has the following type for a specific message code: :data_request or :data_indicator -&gt; KNXexIP.Frames.RoutingIndicationFrame.Data Any other -&gt; KNXexIP.Frames.RoutingIndicationFrame.Raw","ref":"KNXexIP.Frames.RoutingIndicationFrame.html","title":"KNXexIP.Frames.RoutingIndicationFrame","type":"module"},{"doc":"KNX message codes.","ref":"KNXexIP.Frames.RoutingIndicationFrame.html#t:message_code/0","title":"KNXexIP.Frames.RoutingIndicationFrame.message_code/0","type":"type"},{"doc":"Represents a KNX Routing Indication frame.","ref":"KNXexIP.Frames.RoutingIndicationFrame.html#t:t/0","title":"KNXexIP.Frames.RoutingIndicationFrame.t/0","type":"type"},{"doc":"This module contains the data of Routing Indication Frames, that have the message code data_indicator or data_request . These type of frames are used to send GroupValueRead, GroupValueRespond and GroupValueWrite requests, among other telegrams.","ref":"KNXexIP.Frames.RoutingIndicationFrame.Data.html","title":"KNXexIP.Frames.RoutingIndicationFrame.Data","type":"module"},{"doc":"KNX Application Layer Protocol Control Information (APCI). The APCI defines the service. See also https://support.KNXexIP.org/hc/en-us/articles/115003188529-Payload .","ref":"KNXexIP.Frames.RoutingIndicationFrame.Data.html#t:apci/0","title":"KNXexIP.Frames.RoutingIndicationFrame.Data.apci/0","type":"type"},{"doc":"Represents a data service frame.","ref":"KNXexIP.Frames.RoutingIndicationFrame.Data.html#t:t/0","title":"KNXexIP.Frames.RoutingIndicationFrame.Data.t/0","type":"type"},{"doc":"This module contains the raw data of Routing Indication Frames. That is, this struct gets used, when the message code of any other RoutingIndicationFrame does not match.","ref":"KNXexIP.Frames.RoutingIndicationFrame.Raw.html","title":"KNXexIP.Frames.RoutingIndicationFrame.Raw","type":"module"},{"doc":"Represents a raw service frame.","ref":"KNXexIP.Frames.RoutingIndicationFrame.Raw.html#t:t/0","title":"KNXexIP.Frames.RoutingIndicationFrame.Raw.t/0","type":"type"},{"doc":"KNX Routing Lost Message Frame.","ref":"KNXexIP.Frames.RoutingLostMessageFrame.html","title":"KNXexIP.Frames.RoutingLostMessageFrame","type":"module"},{"doc":"Represents a KNX Routing Lost Message frame.","ref":"KNXexIP.Frames.RoutingLostMessageFrame.html#t:t/0","title":"KNXexIP.Frames.RoutingLostMessageFrame.t/0","type":"type"},{"doc":"KNX Search Request Frame. This frame does have a frame encoder implementation.","ref":"KNXexIP.Frames.SearchRequestFrame.html","title":"KNXexIP.Frames.SearchRequestFrame","type":"module"},{"doc":"Represents a KNX Search Request frame.","ref":"KNXexIP.Frames.SearchRequestFrame.html#t:t/0","title":"KNXexIP.Frames.SearchRequestFrame.t/0","type":"type"},{"doc":"KNX Search Response Frame. This frame does have a frame encoder implementation.","ref":"KNXexIP.Frames.SearchResponseFrame.html","title":"KNXexIP.Frames.SearchResponseFrame","type":"module"},{"doc":"Represents a KNX Search Response frame.","ref":"KNXexIP.Frames.SearchResponseFrame.html#t:t/0","title":"KNXexIP.Frames.SearchResponseFrame.t/0","type":"type"},{"doc":"KNX telegrams GenStage producer and broadcast dispatcher.","ref":"KNXexIP.GenStageProducer.html","title":"KNXexIP.GenStageProducer","type":"module"},{"doc":"Starts the GenStage producer and broadcast dispatcher.","ref":"KNXexIP.GenStageProducer.html#start_link/1","title":"KNXexIP.GenStageProducer.start_link/1","type":"function"},{"doc":"Subscribes to the given KNX interface and thus receives KNX telegrams from it. The received KNX telegrams are forwarded as GenStage events, in the form of {:knx, KNXexIP.Telegram.t()} . This producer can also subscribe to GroupAddressServer , which will give you better information about the group address, but less information about the source. However said server uses a different struct and does not emit telegrams. You will receive {:knx_group, GroupAddressData.t()} events in that case.","ref":"KNXexIP.GenStageProducer.html#subscribe_to/3","title":"KNXexIP.GenStageProducer.subscribe_to/3","type":"function"},{"doc":"Unsubscribes from the given KNX interface. KNX telegrams cannot be received from it anymore.","ref":"KNXexIP.GenStageProducer.html#unsubscribe_from/3","title":"KNXexIP.GenStageProducer.unsubscribe_from/3","type":"function"},{"doc":"KNX group address.","ref":"KNXexIP.GroupAddress.html","title":"KNXexIP.GroupAddress","type":"module"},{"doc":"Parses the raw group address (16bit integer) into a GroupAddress struct.","ref":"KNXexIP.GroupAddress.html#from_raw_address/1","title":"KNXexIP.GroupAddress.from_raw_address/1","type":"function"},{"doc":"Parses a group address from a string into a GroupAddress struct.","ref":"KNXexIP.GroupAddress.html#from_string/1","title":"KNXexIP.GroupAddress.from_string/1","type":"function"},{"doc":"Creates a GroupAddress struct from the given main , middle and sub group addresses parts.","ref":"KNXexIP.GroupAddress.html#make/3","title":"KNXexIP.GroupAddress.make/3","type":"function"},{"doc":"Returns the raw group address (16bit integer).","ref":"KNXexIP.GroupAddress.html#to_raw_address/1","title":"KNXexIP.GroupAddress.to_raw_address/1","type":"function"},{"doc":"Returns the group address as a string.","ref":"KNXexIP.GroupAddress.html#to_string/1","title":"KNXexIP.GroupAddress.to_string/1","type":"function"},{"doc":"Represents a KNX group address.","ref":"KNXexIP.GroupAddress.html#t:t/0","title":"KNXexIP.GroupAddress.t/0","type":"type"},{"doc":"The KNX Group Address Server listens for KNX group telegrams and stores their values. The group addresses must be known by this server and the KNX client, in order to be able to decode and encode the value. Unknown group addresses by this server are ignored, even if received and decoded by the KNX client. Group addresses without a type found in the :ets_project are filtered out. In other cases, where group addresses is explicitely given, an exception is raised. The server can read all relevant group addresses from the KNX bus on startup to hydrate the values. To avoid reading group addresses on startup from the KNX bus, an alternative approach to hydrate the group addresses state can be provided by the hydratation_state option. During hydration, the server does not answer any requests. This server uses one ETS table to store the data. Multiple instances of this server should be carefully considered, as the ETS table is shared. Each function takes an opts keyword list, which can have an optional :name option, which is then used to call the MulticastClient identified by the :name (a PID or registered name), and an optional :timeout option (defaults to 5000).","ref":"KNXexIP.GroupAddressServer.html","title":"KNXexIP.GroupAddressServer","type":"module"},{"doc":"Adds the given group address with the datapoint type (DPT) to the group address list. Unknown group addresses can not be used to send or receive telegrams. The DPT is in the form of &quot;x.yyy&quot; where x and y are numbers, i.e. 1.001 . The following options are additionally supported: hydrate: boolean() - Optional. Specifies whether the group address should be read to hydrate the value (defaults to false ).","ref":"KNXexIP.GroupAddressServer.html#add/3","title":"KNXexIP.GroupAddressServer.add/3","type":"function"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor .","ref":"KNXexIP.GroupAddressServer.html#child_spec/1","title":"KNXexIP.GroupAddressServer.child_spec/1","type":"function"},{"doc":"Creates the ETS table. The current process will be the owner of the table. The table should be created before starting the server, if multiple are started. This would prevent losing the whole table if one server crashes. The ETS table will be automatically created in the server process, if it does not exist, however. If the ETS table already exists, the table identifier will be returned. The owner is not modified.","ref":"KNXexIP.GroupAddressServer.html#create_ets_table/0","title":"KNXexIP.GroupAddressServer.create_ets_table/0","type":"function"},{"doc":"This is a helper function that takes an ETS project struct, optionally the path to the ETS project file, and whether group addresses which have an unknown read flag should be read from the KNX bus. The ETS project file MUST exist, as it must be read from disk to read the manufacturer data. As output you will receive a list of group addresses that can be read from the KNX bus, optionally with group addresses that may be readable. The following optional options can be given: allow_nil: boolean() - Whether group addresses that have an unknown read flag should be read from the KNX bus (defaults to true ). manufacturer_map: map() - A map from KNXexIP.ProjectParser.parse_manufacturers/2 , if it has already been done before. This helps not having to parse the ETS project file again. If not given, it will be parsed from the ETS project file. path: String.t() - The path to the ETS project file. If not given, the path from the ETS project struct is used. All other given elements in opts are passed to KNXexIP.ProjectParser.parse_manufacturers/2 .","ref":"KNXexIP.GroupAddressServer.html#filter_gpa_hydration_by_read_flag/2","title":"KNXexIP.GroupAddressServer.filter_gpa_hydration_by_read_flag/2","type":"function"},{"doc":"Gets all group addresses from the ETS table.","ref":"KNXexIP.GroupAddressServer.html#get_group_addresses/0","title":"KNXexIP.GroupAddressServer.get_group_addresses/0","type":"function"},{"doc":"Reads the group address from the ETS table. If specified, the value will be read from the KNX bus, if the value is nil . The function can also be instructed to read the value from the KNX bus, regardless whether the value is available or not. The following options are additionally supported: force_value_read: boolean() - Optional. Specifies whether the group address must be read from the KNX bus before returning it (defaults to false ). read_value_on_nil: boolean() - Optional. Specifies whether the group address is read from the KNX bus before returning, if the value is nil (defaults to false ).","ref":"KNXexIP.GroupAddressServer.html#read/2","title":"KNXexIP.GroupAddressServer.read/2","type":"function"},{"doc":"Removes the given group address from the group address list.","ref":"KNXexIP.GroupAddressServer.html#remove/1","title":"KNXexIP.GroupAddressServer.remove/1","type":"function"},{"doc":"Starts a new Group Address Server. The group addresses with their name and type is read from the ETS project file (.knxproj export). The following options are available (some are required): ets_project: KNXexIP.EtsProject.t() | path :: binary() - Required. The ETS project to use, or the path to the ETS project file. hydrate_on_start: boolean() | [address :: binary()] - Optional. Whether to hydrate the group addresses state on startup, by reading the group addresses from the KNX bus. If true , all group addresses are read. If a list of group addresses is given (in x/y/z format), only those are read. hydration_state: [hydration_state_item()] - Optional. The hydration state to use when hydrating the group addresses state on startup. If not given and hydrate_on_start is given, the hydration state is read from the KNX bus. hydration_timeout: pos_integer() - Optional. The timeout used when hydrating the state from the KNX bus (defaults to 5000 ms). knx_interface: module() | {module(), atom() | pid()} - Required. The KNX interface to use. The module name or a tuple of module name and PID/registered name. The only supported KNX interface modules are MulticastClient and TunnelClient currently.","ref":"KNXexIP.GroupAddressServer.html#start_link/1","title":"KNXexIP.GroupAddressServer.start_link/1","type":"function"},{"doc":"Sets the subscriber to the given PID. The PID is not checked for aliveness. Only a single subscriber is supported. This function is used with the GenStageProducer .","ref":"KNXexIP.GroupAddressServer.html#subscribe/2","title":"KNXexIP.GroupAddressServer.subscribe/2","type":"function"},{"doc":"Converts the current ETS table state into an usable hydration state. Group addresses without a value are skipped.","ref":"KNXexIP.GroupAddressServer.html#to_hydration_state/0","title":"KNXexIP.GroupAddressServer.to_hydration_state/0","type":"function"},{"doc":"Unsets the subscriber. The first argument is ignored and only for compatibility. This function is used with the GenStageProducer .","ref":"KNXexIP.GroupAddressServer.html#unsubscribe/2","title":"KNXexIP.GroupAddressServer.unsubscribe/2","type":"function"},{"doc":"Waits for the startup sequence to complete. This will block indefinitely until the server replies. This is useful during hydration, to wait until the hydration is completed and available to answer requests.","ref":"KNXexIP.GroupAddressServer.html#wait_for_startup/1","title":"KNXexIP.GroupAddressServer.wait_for_startup/1","type":"function"},{"doc":"Writes the group address. The value is written to the KNX bus and then stored in the ETS table.","ref":"KNXexIP.GroupAddressServer.html#write/3","title":"KNXexIP.GroupAddressServer.write/3","type":"function"},{"doc":"","ref":"KNXexIP.GroupAddressServer.html#t:hydration_state_item/0","title":"KNXexIP.GroupAddressServer.hydration_state_item/0","type":"type"},{"doc":"The KNX Group Address server's group address data structure.","ref":"KNXexIP.GroupAddressServer.GroupAddressData.html","title":"KNXexIP.GroupAddressServer.GroupAddressData","type":"module"},{"doc":"Represents the KNX group address, that is used in this server. In addition to KNXexIP.GroupAddress.t() , the name, last update time and value are stored. If the value is nil , the value is not known (has not been hydrated or received from the KNX bus yet). Type is a tuple of name and type, i.e. {&quot;DPT_Switch&quot;, &quot;1.001&quot;} .","ref":"KNXexIP.GroupAddressServer.GroupAddressData.html#t:t/0","title":"KNXexIP.GroupAddressServer.GroupAddressData.t/0","type":"type"},{"doc":"KNX individual address (also known as physical address).","ref":"KNXexIP.IndividualAddress.html","title":"KNXexIP.IndividualAddress","type":"module"},{"doc":"Parses the raw individual address (16bit integer) into a IndividualAddress struct.","ref":"KNXexIP.IndividualAddress.html#from_raw_address/1","title":"KNXexIP.IndividualAddress.from_raw_address/1","type":"function"},{"doc":"Parses a individual address from a string into a IndividualAddress struct.","ref":"KNXexIP.IndividualAddress.html#from_string/1","title":"KNXexIP.IndividualAddress.from_string/1","type":"function"},{"doc":"Creates a IndividualAddress struct from the given area , line and device individual addresses parts.","ref":"KNXexIP.IndividualAddress.html#make/3","title":"KNXexIP.IndividualAddress.make/3","type":"function"},{"doc":"Returns the raw individual address (16bit integer).","ref":"KNXexIP.IndividualAddress.html#to_raw_address/1","title":"KNXexIP.IndividualAddress.to_raw_address/1","type":"function"},{"doc":"Returns the individual address as a string.","ref":"KNXexIP.IndividualAddress.html#to_string/1","title":"KNXexIP.IndividualAddress.to_string/1","type":"function"},{"doc":"Represents a KNX individual address.","ref":"KNXexIP.IndividualAddress.html#t:t/0","title":"KNXexIP.IndividualAddress.t/0","type":"type"},{"doc":"KNXnet/IP Multicast Client. The KNX Multicast Client uses multicast to send and receive KNX telegrams (or any other KNX frame). The Client adds its membership to the multicast group and listens for incoming telegrams. Outgoing KNX frames are sent using multicast, too. The KNX/IP router must be correctly configured to forward the KNX frame to their KNX/TP connection. You may have multiple for each area or line, so the correct KNX/IP router, that should forward the KNX frame, must have the filter table correctly configured. Each function takes an opts keyword list, which can have an optional :name option, which is then used to call the MulticastClient identified by the :name (a PID or registered name), and an optional :timeout option (defaults to 5000).","ref":"KNXexIP.MulticastClient.html","title":"KNXexIP.MulticastClient","type":"module"},{"doc":"Adds the given group address with the datapoint type (DPT) to the group address list. Unknown group addresses can not be used to send or receive telegrams. The DPT is in the form of &quot;x.yyy&quot; where x and y are numbers, i.e. 1.001 .","ref":"KNXexIP.MulticastClient.html#add_group_address/3","title":"KNXexIP.MulticastClient.add_group_address/3","type":"function"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor .","ref":"KNXexIP.MulticastClient.html#child_spec/1","title":"KNXexIP.MulticastClient.child_spec/1","type":"function"},{"doc":"Gets all group addresses from the state.","ref":"KNXexIP.MulticastClient.html#get_group_addresses/1","title":"KNXexIP.MulticastClient.get_group_addresses/1","type":"function"},{"doc":"Sends a GroupValueRead to group_address . Waits up to get_opts_timeout() for the response. Utilizes a Task to subscribe temporarily to events.","ref":"KNXexIP.MulticastClient.html#read_group_address/2","title":"KNXexIP.MulticastClient.read_group_address/2","type":"function"},{"doc":"Removes the given group address from the group address list.","ref":"KNXexIP.MulticastClient.html#remove_group_address/2","title":"KNXexIP.MulticastClient.remove_group_address/2","type":"function"},{"doc":"Sends a raw frame. The frame body must be binary or have a FrameEncoder implementation. If the frame body is a frame, the request_type can be set to :auto and it will be derived from the FrameEncoder implementation.","ref":"KNXexIP.MulticastClient.html#send_frame/2","title":"KNXexIP.MulticastClient.send_frame/2","type":"function"},{"doc":"Starts the KNXnet/IP Multicast Client. The following options are available (some are required): allow_unknown_gpa: boolean() - Optional. Determines whether unknown Group Addresses are allowed (not ignored when received, defaults to false ). This will also mean that you receive the raw undecoded value and you need to provide the raw encoded value when sending. frame_callback: (KNXexIP.Frame.t(), :handled | unhandled) -&gt; any() - Optional. A callback module can be specified, that will be called for all frames which are not explicitely handled by this server module. Two arity: (KNXexIP.Frame.t(), :handled | :unhandled) - :handled for frames handled by this server module. group_addresses: map() - Required. Group addresses map, where the key is the group address in x/y/z notation and the value is the DPT (datapoint type) - both being String.t() . The group address and its DPT is required to determine how to encode and decode received values. local_ip: :inet.ip4_address() - Optional. The local IP address to use. If nil, the local IP address will be discovered. multicast_ip: :inet.ip4_address() - Optional. The multicast IP address to use. If nil, it will default to 224.0.23.12 . source_address: KNXexIP.IndividualAddress.t() - Required. The KNX individual address that will be used as source address for all non-raw frames. The source address is required, as the KNX/IP router does not fill it in, if the source is 0.0.0 (it is transmitted as-is to the KNX bus). All other given options are passed to the GenServer module (i.e. :name can be given to override the process name to register).","ref":"KNXexIP.MulticastClient.html#start_link/1","title":"KNXexIP.MulticastClient.start_link/1","type":"function"},{"doc":"Subscribes to telegram notifications. The subscriber will receive messages in the form {:knx, KNXexIP.Telegram.t()} .","ref":"KNXexIP.MulticastClient.html#subscribe/2","title":"KNXexIP.MulticastClient.subscribe/2","type":"function"},{"doc":"Unsubscribes from telegram notifications.","ref":"KNXexIP.MulticastClient.html#unsubscribe/2","title":"KNXexIP.MulticastClient.unsubscribe/2","type":"function"},{"doc":"Encodes value according to the DPT of the group_address , and sends it in a GroupValueWrite to group_address . The returned reference is currently without any meaning to the user.","ref":"KNXexIP.MulticastClient.html#write_group_address/3","title":"KNXexIP.MulticastClient.write_group_address/3","type":"function"},{"doc":"KNXnet/IP Parameter Object &quot;Device Capabilities&quot;.","ref":"KNXexIP.PID.DeviceCapabilities.html","title":"KNXexIP.PID.DeviceCapabilities","type":"module"},{"doc":"","ref":"KNXexIP.PID.DeviceCapabilities.html#assert_name/2","title":"KNXexIP.PID.DeviceCapabilities.assert_name/2","type":"function"},{"doc":"","ref":"KNXexIP.PID.DeviceCapabilities.html#by_name/2","title":"KNXexIP.PID.DeviceCapabilities.by_name/2","type":"function"},{"doc":"","ref":"KNXexIP.PID.DeviceCapabilities.html#by_value/2","title":"KNXexIP.PID.DeviceCapabilities.by_value/2","type":"function"},{"doc":"Checks if the given device capabilities has the device management capability bit set.","ref":"KNXexIP.PID.DeviceCapabilities.html#has_device_management/1","title":"KNXexIP.PID.DeviceCapabilities.has_device_management/1","type":"macro"},{"doc":"Checks if the given device capabilities has the object server capability bit set.","ref":"KNXexIP.PID.DeviceCapabilities.html#has_object_server/1","title":"KNXexIP.PID.DeviceCapabilities.has_object_server/1","type":"macro"},{"doc":"Checks if the given device capabilities has the remote configuration and diagnosis capability bit set.","ref":"KNXexIP.PID.DeviceCapabilities.html#has_remote_conf_and_diag/1","title":"KNXexIP.PID.DeviceCapabilities.has_remote_conf_and_diag/1","type":"macro"},{"doc":"Checks if the given device capabilities has the remote logging capability bit set.","ref":"KNXexIP.PID.DeviceCapabilities.html#has_remote_logging/1","title":"KNXexIP.PID.DeviceCapabilities.has_remote_logging/1","type":"macro"},{"doc":"Checks if the given device capabilities has the routing capability bit set.","ref":"KNXexIP.PID.DeviceCapabilities.html#has_routing/1","title":"KNXexIP.PID.DeviceCapabilities.has_routing/1","type":"macro"},{"doc":"Checks if the given device capabilities has the tunneling capability bit set.","ref":"KNXexIP.PID.DeviceCapabilities.html#has_tunneling/1","title":"KNXexIP.PID.DeviceCapabilities.has_tunneling/1","type":"macro"},{"doc":"","ref":"KNXexIP.PID.DeviceCapabilities.html#macro_assert_name/2","title":"KNXexIP.PID.DeviceCapabilities.macro_assert_name/2","type":"macro"},{"doc":"","ref":"KNXexIP.PID.DeviceCapabilities.html#macro_by_name/2","title":"KNXexIP.PID.DeviceCapabilities.macro_by_name/2","type":"macro"},{"doc":"","ref":"KNXexIP.PID.DeviceCapabilities.html#macro_by_value/2","title":"KNXexIP.PID.DeviceCapabilities.macro_by_value/2","type":"macro"},{"doc":"KNXnet/IP Parameter Object &quot;Device State&quot;.","ref":"KNXexIP.PID.DeviceState.html","title":"KNXexIP.PID.DeviceState","type":"module"},{"doc":"","ref":"KNXexIP.PID.DeviceState.html#assert_name/2","title":"KNXexIP.PID.DeviceState.assert_name/2","type":"function"},{"doc":"","ref":"KNXexIP.PID.DeviceState.html#by_name/2","title":"KNXexIP.PID.DeviceState.by_name/2","type":"function"},{"doc":"","ref":"KNXexIP.PID.DeviceState.html#by_value/2","title":"KNXexIP.PID.DeviceState.by_value/2","type":"function"},{"doc":"Checks if the given device state has the IP fault bit set.","ref":"KNXexIP.PID.DeviceState.html#is_ip_fault/1","title":"KNXexIP.PID.DeviceState.is_ip_fault/1","type":"macro"},{"doc":"Checks if the given device state has the KNX fault bit set.","ref":"KNXexIP.PID.DeviceState.html#is_knx_fault/1","title":"KNXexIP.PID.DeviceState.is_knx_fault/1","type":"macro"},{"doc":"","ref":"KNXexIP.PID.DeviceState.html#macro_assert_name/2","title":"KNXexIP.PID.DeviceState.macro_assert_name/2","type":"macro"},{"doc":"","ref":"KNXexIP.PID.DeviceState.html#macro_by_name/2","title":"KNXexIP.PID.DeviceState.macro_by_name/2","type":"macro"},{"doc":"","ref":"KNXexIP.PID.DeviceState.html#macro_by_value/2","title":"KNXexIP.PID.DeviceState.macro_by_value/2","type":"macro"},{"doc":"KNXnet/IP Parameter Object &quot;IP Assignment Method&quot;.","ref":"KNXexIP.PID.IPAssignmentMethod.html","title":"KNXexIP.PID.IPAssignmentMethod","type":"module"},{"doc":"","ref":"KNXexIP.PID.IPAssignmentMethod.html#assert_name/2","title":"KNXexIP.PID.IPAssignmentMethod.assert_name/2","type":"function"},{"doc":"","ref":"KNXexIP.PID.IPAssignmentMethod.html#by_name/2","title":"KNXexIP.PID.IPAssignmentMethod.by_name/2","type":"function"},{"doc":"","ref":"KNXexIP.PID.IPAssignmentMethod.html#by_value/2","title":"KNXexIP.PID.IPAssignmentMethod.by_value/2","type":"function"},{"doc":"","ref":"KNXexIP.PID.IPAssignmentMethod.html#macro_assert_name/2","title":"KNXexIP.PID.IPAssignmentMethod.macro_assert_name/2","type":"macro"},{"doc":"","ref":"KNXexIP.PID.IPAssignmentMethod.html#macro_by_name/2","title":"KNXexIP.PID.IPAssignmentMethod.macro_by_name/2","type":"macro"},{"doc":"","ref":"KNXexIP.PID.IPAssignmentMethod.html#macro_by_value/2","title":"KNXexIP.PID.IPAssignmentMethod.macro_by_value/2","type":"macro"},{"doc":"Turns the given integer into the corresponding atom.","ref":"KNXexIP.PID.IPAssignmentMethod.html#to_atom/1","title":"KNXexIP.PID.IPAssignmentMethod.to_atom/1","type":"function"},{"doc":"Turns the given atom into the correct integer value.","ref":"KNXexIP.PID.IPAssignmentMethod.html#to_integer/1","title":"KNXexIP.PID.IPAssignmentMethod.to_integer/1","type":"function"},{"doc":"The KNX device's IP assignment method.","ref":"KNXexIP.PID.IPAssignmentMethod.html#t:method/0","title":"KNXexIP.PID.IPAssignmentMethod.method/0","type":"type"},{"doc":"KNXnet/IP Parameter Object &quot;KNXnet/IP Routing Capabilities&quot;.","ref":"KNXexIP.PID.KNXnetRoutingCapabilities.html","title":"KNXexIP.PID.KNXnetRoutingCapabilities","type":"module"},{"doc":"","ref":"KNXexIP.PID.KNXnetRoutingCapabilities.html#assert_name/2","title":"KNXexIP.PID.KNXnetRoutingCapabilities.assert_name/2","type":"function"},{"doc":"","ref":"KNXexIP.PID.KNXnetRoutingCapabilities.html#by_name/2","title":"KNXexIP.PID.KNXnetRoutingCapabilities.by_name/2","type":"function"},{"doc":"","ref":"KNXexIP.PID.KNXnetRoutingCapabilities.html#by_value/2","title":"KNXexIP.PID.KNXnetRoutingCapabilities.by_value/2","type":"function"},{"doc":"Checks if the given routing capabilities has the group address mapping capability bit set.","ref":"KNXexIP.PID.KNXnetRoutingCapabilities.html#has_group_address_mapping/1","title":"KNXexIP.PID.KNXnetRoutingCapabilities.has_group_address_mapping/1","type":"macro"},{"doc":"Checks if the given routing capabilities has the multiple KNX installations capability bit set.","ref":"KNXexIP.PID.KNXnetRoutingCapabilities.html#has_multiple_knx_installations/1","title":"KNXexIP.PID.KNXnetRoutingCapabilities.has_multiple_knx_installations/1","type":"macro"},{"doc":"Checks if the given routing capabilities has the priority/FIFO capability bit set.","ref":"KNXexIP.PID.KNXnetRoutingCapabilities.html#has_priority_fifo/1","title":"KNXexIP.PID.KNXnetRoutingCapabilities.has_priority_fifo/1","type":"macro"},{"doc":"Checks if the given routing capabilities has the statistics queue overflow capability bit set.","ref":"KNXexIP.PID.KNXnetRoutingCapabilities.html#has_stats_queue_overflow/1","title":"KNXexIP.PID.KNXnetRoutingCapabilities.has_stats_queue_overflow/1","type":"macro"},{"doc":"Checks if the given routing capabilities has the statistics transmitted telegrams capability bit set.","ref":"KNXexIP.PID.KNXnetRoutingCapabilities.html#has_stats_transmitted_telegrams/1","title":"KNXexIP.PID.KNXnetRoutingCapabilities.has_stats_transmitted_telegrams/1","type":"macro"},{"doc":"","ref":"KNXexIP.PID.KNXnetRoutingCapabilities.html#macro_assert_name/2","title":"KNXexIP.PID.KNXnetRoutingCapabilities.macro_assert_name/2","type":"macro"},{"doc":"","ref":"KNXexIP.PID.KNXnetRoutingCapabilities.html#macro_by_name/2","title":"KNXexIP.PID.KNXnetRoutingCapabilities.macro_by_name/2","type":"macro"},{"doc":"","ref":"KNXexIP.PID.KNXnetRoutingCapabilities.html#macro_by_value/2","title":"KNXexIP.PID.KNXnetRoutingCapabilities.macro_by_value/2","type":"macro"},{"doc":"KNX project file parser (ETS .knxproj).","ref":"KNXexIP.ProjectParser.html","title":"KNXexIP.ProjectParser","type":"module"},{"doc":"Parses a KNX project file (ETS .knxproj), extracting project information and returns a KNXexIP.EtsProject struct. The following informations get extracted: Project Information (name, comment, project number, project start/end, etc.) Group Addresses with the DPT Topology (Area, Line, Device, Unassigned Devices) Device Additional Attributes (i.e. IP config, if enabled) Device Communication Objects (if enabled) Device Parameters (if enabled) The following options are available: only: [atom()] - Only the specified information groups will be parsed, the following groups are available: project_info , group_addresses , topology . exclude: [atom()] - The specified information groups will be excluded (see only ), only and exclude are mutually exclusive. include_dev_add_attributes: boolean() - Include additional attributes from the device (default: false ). include_dev_com_objects: boolean() - Include communication objects from the device (default: false ). include_dev_parameters: boolean() - Include parameters from the device (default: false ). group_addresses_key: :id | :address - The key to use for the group addresses map (default: :address ). This function will raise on errors.","ref":"KNXexIP.ProjectParser.html#parse/2","title":"KNXexIP.ProjectParser.parse/2","type":"function"},{"doc":"Parses a KNX project file (ETS .knxproj), extracting manufacturer information and returns a map. The following informations get extracted: Application Programs (basic information and communication objects) Hardware &amp; products (basic information) Hardware-to-Program mappings The following options are available: only: [String.t()] - Only the specified manufacturers will be parsed, the manufacturer ID, i.e. M-0001 , is required. exclude: [String.t()] - The specified manufacturers will be excluded (see only ), only and exclude are mutually exclusive. parallel: boolean() - Whether to parse the manufacturers in parallel using Task.async_stream/5 (default: false ). parallel_timeout: pos_integer() - The timeout for parallel parsing (default: 60_000 ms). This function will raise on errors. Example output: %{ &quot;M-00C9&quot; =&gt; %{ application_programs : %{ &quot;M-00C9_A-FF14-20-223D&quot; =&gt; % KNXexIP.EtsProject.Manufacturer.ApplicationProgram { app_number : &quot;65300&quot; , app_version : &quot;32&quot; , com_objects : %{ &quot;O-12&quot; =&gt; % KNXexIP.EtsProject.Topology.Device.ComObject { communication_flag : true , description : nil , dpt : nil , function_text : &quot;Eingang&quot; , id : &quot;O-12&quot; , links : nil , number : 12 , object_size : 1 , priority : nil , read_flag : false , read_on_init_flag : false , text : &quot;Temp. Grenzwert 1: Schaltausgang Sperre&quot; , transmit_flag : false , update_flag : false , write_flag : true } } , description : &quot;KNX TH-UP&quot; , dynamic_table_management : true , hash : &quot;Iss9qvKKsV5qnWizDXWVPQ==&quot; , id : &quot;M-00C9_A-FF14-20-223D&quot; , linkable : false , mask_version : &quot;MV-0701&quot; , name : &quot;KNX App_20&quot; , program_type : &quot;ApplicationProgram&quot; } } , hardware : %{ &quot;M-00C9_H-70121-1&quot; =&gt; % KNXexIP.EtsProject.Manufacturer.Hardware { bus_current : 10 , hardware2programs : %{ &quot;M-00C9_H-70121-1_HP-FF14-20-223D&quot; =&gt; % KNXexIP.EtsProject.Manufacturer.Hardware.Hardware2Program { application_program_refid : &quot;M-00C9_A-FF14-20-223D&quot; , hash : &quot;SdI1o0jhKfnXwWt3Gf3qOvC/z4U=&quot; , id : &quot;M-00C9_H-70121-1_HP-FF14-20-223D&quot; , medium_types : [ :tp ] } } , has_application_program : true , has_individual_address : true , id : &quot;M-00C9_H-70121-1&quot; , is_coupler : nil , is_ip_enabled : nil , is_power_supply : nil , name : &quot;KNX T-AP&quot; , products : %{ &quot;M-00C9_H-70121-1_P-70121&quot; =&gt; % KNXexIP.EtsProject.Manufacturer.Hardware.Product { hash : &quot;H1+DOySrz+UUcxCBvF0s8MIyIak=&quot; , id : &quot;M-00C9_H-70121-1_P-70121&quot; , is_rail_mounted : false , order_number : &quot;70121&quot; , text : &quot;KNX T-AP&quot; , width : nil } } , serialnum : &quot;70121&quot; , version : &quot;1&quot; } } } }","ref":"KNXexIP.ProjectParser.html#parse_manufacturers/2","title":"KNXexIP.ProjectParser.parse_manufacturers/2","type":"function"},{"doc":"KNX Transport Layer Protocol Control Information (TPCI). See also https://support.KNXexIP.org/hc/en-us/articles/115003188529-Payload .","ref":"KNXexIP.TPCI.html","title":"KNXexIP.TPCI","type":"module"},{"doc":"Creates a new TPCI struct from the raw TPCI value.","ref":"KNXexIP.TPCI.html#make/1","title":"KNXexIP.TPCI.make/1","type":"function"},{"doc":"Calculates the integer value for the given TPCI struct.","ref":"KNXexIP.TPCI.html#to_integer/1","title":"KNXexIP.TPCI.to_integer/1","type":"function"},{"doc":"Defines what type of packet it is.","ref":"KNXexIP.TPCI.html#t:control_data/0","title":"KNXexIP.TPCI.control_data/0","type":"type"},{"doc":"Represents the TPCI.","ref":"KNXexIP.TPCI.html#t:t/0","title":"KNXexIP.TPCI.t/0","type":"type"},{"doc":"Defines the purpose of the packet and whether it contains a sequence number.","ref":"KNXexIP.TPCI.html#t:type/0","title":"KNXexIP.TPCI.type/0","type":"type"},{"doc":"KNX telegram.","ref":"KNXexIP.Telegram.html","title":"KNXexIP.Telegram","type":"module"},{"doc":"Represents a KNX telegram.","ref":"KNXexIP.Telegram.html#t:t/0","title":"KNXexIP.Telegram.t/0","type":"type"},{"doc":"KNXnet/IP Tunnel Client, which wraps around the KNXnetIP.Tunnel behaviour module. The KNX Tunnel Client connects to a KNXnet/IP server (gateway or router) using a tunnelling connection, to send and receive KNX telegrams. Processes interested in receiving received KNX telegram need to subscribe to them, using subscribe/1 and unsubscribe/1 to unsubscribe from them. Each function takes an opts keyword list, which can have an optional :name option, which is then used to call the TunnelClient identified by the :name (a PID or registered name), and an optional :timeout option (defaults to 5000).","ref":"KNXexIP.TunnelClient.html","title":"KNXexIP.TunnelClient","type":"module"},{"doc":"Adds the given group address with the datapoint type (DPT) to the group address list. Unknown group addresses can not be used to send or receive telegrams. The DPT is in the form of &quot;x.yyy&quot; where x and y are numbers, i.e. 1.001 .","ref":"KNXexIP.TunnelClient.html#add_group_address/3","title":"KNXexIP.TunnelClient.add_group_address/3","type":"function"},{"doc":"Disconnects from the KNX/IP gateway/router and closes the KNXnet Tunnel server.","ref":"KNXexIP.TunnelClient.html#close/1","title":"KNXexIP.TunnelClient.close/1","type":"function"},{"doc":"Gets all group addresses from the state.","ref":"KNXexIP.TunnelClient.html#get_group_addresses/1","title":"KNXexIP.TunnelClient.get_group_addresses/1","type":"function"},{"doc":"Sends a GroupValueRead to group_address . Waits up to timeout for the response. Utilizes a Task to subscribe temporarily to events.","ref":"KNXexIP.TunnelClient.html#read_group_address/2","title":"KNXexIP.TunnelClient.read_group_address/2","type":"function"},{"doc":"Removes the given group address from the group address list.","ref":"KNXexIP.TunnelClient.html#remove_group_address/2","title":"KNXexIP.TunnelClient.remove_group_address/2","type":"function"},{"doc":"Sends a raw telegram. The returned reference is currently without any meaning to the user.","ref":"KNXexIP.TunnelClient.html#send_raw_telegram/2","title":"KNXexIP.TunnelClient.send_raw_telegram/2","type":"function"},{"doc":"Sends a telegram. The DPT of the group_address must be known. The returned reference is currently without any meaning to the user.","ref":"KNXexIP.TunnelClient.html#send_telegram/2","title":"KNXexIP.TunnelClient.send_telegram/2","type":"function"},{"doc":"Starts the KNXnet/IP Tunnel Client. The following options are available (some are required): allow_unknown_gpa: boolean() - Optional. Determines whether unknown Group Addresses are allowed (not ignored when received, defaults to false ). This will also mean that you receive the raw undecoded value and you need to provide the raw encoded value when sending. group_addresses: map() - Required. Group addresses map, where the key is the group address in x/y/z notation and the value is the DPT (datapoint type) - both being String.t() . The group address and its DPT is required to determine how to encode and decode received values. local_ip: :inet.ip4_address() - Optional. The local IP address to use. If nil, the local IP address will be discovered. server_ip: :inet.ip4_address() - Required. The KNX/IP gateway/router IP address to connect to. All other given options are passed to the Tunnel behaviour module (i.e. :name can be given to override the process name to register).","ref":"KNXexIP.TunnelClient.html#start_link/1","title":"KNXexIP.TunnelClient.start_link/1","type":"function"},{"doc":"Subscribes to telegram notifications. The subscriber will receive messages in the form {:knx, KNXexIP.Telegram.t()} .","ref":"KNXexIP.TunnelClient.html#subscribe/2","title":"KNXexIP.TunnelClient.subscribe/2","type":"function"},{"doc":"Unsubscribes from telegram notifications.","ref":"KNXexIP.TunnelClient.html#unsubscribe/2","title":"KNXexIP.TunnelClient.unsubscribe/2","type":"function"},{"doc":"Encodes value according to the DPT of the group_address , and sends it in a GroupValueWrite to group_address .","ref":"KNXexIP.TunnelClient.html#write_group_address/3","title":"KNXexIP.TunnelClient.write_group_address/3","type":"function"}]